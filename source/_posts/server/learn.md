---
title: 从0开始学架构【笔记】
date: 2018-8-15
tags: [笔记]
categories: 笔记
---

[从0开始学架构--李运华](https://time.geekbang.org/column/81)

- 软件架构需要根据业务发展不断变化
- 机器语言：三难 难读、难写、难改
- 汇编语言：还是难写
- 高级语言：不关注低级结构和逻辑

- 结构化编程
  - 第一次软件危机（逻辑难拓展）
  - 《人月神话》
  - 结构化程序设计
  - 模块
  - 非goto “自顶向下、逐步细化、模块化”

- 面向对象编程
  - 第二次软件危机（结构难拓展）
  - 面向对象设计 / C++

- 软件架构
  - 系统规模的增加，算法、数据结构不再是主要的问题 
  - 系统规模庞大，内部耦合严重，开发效率低
  - 系统耦合严重，牵一发动全身，后续修改和扩展困难
  - 系统逻辑复杂，容易出问题，出问题后很难排查和修复

- 软件开发过程包括了分析、设计、实现、测试、验证、部署、运维等多个环节。从IT技术的发展历程来看，先辈们在上述不同的环节中提出过很多在当时看来很先进的方法与理念。但是，这些方法、理念在摩尔定律、业务创新、技术发展面前都被一一验证了以下观点：我们可以通过诸多方式去接近“银弹”，但很遗憾，软件活动中没有“银弹”

### 架构设计的目的

- 解决软件系统复杂度带来的问题
- 问题的解决
  - 下手
    - 通过熟悉和理解需求，识别系统复杂性所在的地方
  - 时间不够
    - 并不需要面面俱到、也不需要都具备都聚备高性能、高可用、高拓展等特点，而是要识别出复杂点然后针对性的解决问题
  - 参考选择
    - 理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。

  - 需求驱动开发，需求驱动架构
  - 解决软件系统复杂度带来的问题而提出的一种解决方案，方案需要综合各种因素（时间、人力、财务等）

### 复杂度

- 高性能
  - 进程：操作系统来进行资源分配和调度最小单元
  - 线程：程序执行流的最小单元
  - 单机复杂度
  - 集群复杂度
    - 任务分配
    - 任务分解
      - 简单的系统更易实现高性能
      - 针对特定的任务进行拓展

- 高可用
  - 计算高可用
  - 存储高可用
    - 数据不一致对业务带来的影响
    - CAP 一致性、可用性、分区容错性
  - 高可用的状态决策
    - 独裁式
      - 决策者、决策者故障
    - 协商式
      - 主备方案
    - 民主式
      - 投票节点数必须超过系统总节点数一半

- 可扩展性
  - 为了应对将来的需求变化提供的拓展能力
    - 预测变化
    - 封装变化
  - 复杂性
    - 不能每个设计点都考虑可扩展性
    - 不能完全不考虑可扩展性
    - 所有的预测都存在出错的可能性
  - 变化层
    - 将变化的部分封装成变化层
  - 稳定层
    - 将不变的部分封装成稳定层

- 复杂度
  - 成本、安全、规模
  - 低成本
    - 创新
  - 安全
    - 功能安全 （防小偷）
    - 架构安全 （防强盗）
      - 运营商、云服务商强大的带宽和流量清洗
    - 规模
      - 量变引起质变
      - 功能越来越多，导致系统复杂度指数级上升
      - 数据越来越多，系统复杂度发生质变
  - 大数据理论
    - Google File System 是大数据文件存储的技术理论
    - Google MapReduce 是大数据运算的技术理论
    - Google Bigtable 是列式数据存储的技术理论

- 架构设计三原则
  - 合适原则
    - 没有那么多人，却想干那么多活
    - 没有那么多积累，去想一步登天
    - 没有卓越的业务场景，却幻想灵光一现
  - 简单原则
    - 简单优于复杂
    - 复杂性
      - 结构的复杂性
        - 组件越多，越有可能组件故障
        - 组件改动，影响关联的组件
        - 定位一个复杂系统中的问题总是比简单系统更加困难
        - KISS（keep it simple, stupid）
      - 逻辑的复杂性
  - 演化原则
    - 演化优于一步到位
    - 软件架构需要根据业务发展不断变化
    - 设计出来的架构要满足当时的业务需要
    - 架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善
    - 当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续
    - 贪大求全、盲目照搬大公司的做法

- 识别复杂度
  - 将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题
  - 排查法
  - Hadoop 能够将高可用、高性能、大容量三个大数据处理的复杂度问题同时解决

- 设计备选方案
  - 错误做法
    - 做最优的方案
    - 只做一个方案
  - 正确方案
    - 3~5个方案
    - 备选方案差异明显
    - 不局于现有的方案

- 评估
- 质量属性
- 复杂度
- 硬件成本
- 可运维性
- 可靠性
- 人力投入

### 详细设计原则
- Nginx 的负载均衡策略，备选有轮询、权重分配、ip_hash、fair、url_hash
- 一个电商架构，由于和 session 比较强相关，因此如果用 Nginx 来做集群负载均衡，那么选择 ip_hash 策略是比较合适的

### 高性能数据库集群
- 读写分离
  - 读写分离的基本原理是将数据库读写操作分散到不同的节点上
  - 基本实现
    - 数据库服务器搭建主从集群，一主一从、一主多从都是可以
    - 数据库主机负责读写操作，从机只负责度操作
    - 数据库主机通过复制讲数据同步到从机，将读操作发给数据库从机
    - 业务服务器将写操作发给数据库主机，将读操作发给数据从机
  - 注意点
    - 主从复制延迟
    - 分配机制
  - 复制延迟
    - 写操作后的读操作指定发给数据库主服务器
    - 读从机失败后再读一次主机
    - 关键业务读写操作全部指向主机，非关键业务采用读写分离
  - 分配机制
    - 程序代码封装
      - 实现简单，而且可以根据业务做较多定制化的功能
      - 每个编程语言都需要自己实现一次，无法通用，如果一个业务包含多个编程语言写的多个子系统，则重复开发的工作量比较大
      - 故障情况下，如果主从发生切换，则可能需要所有系统都修改配置并重启
    - 中间件封装
      - 能够支持多种编程语言，因为数据库中间件对业务服务器提供的是标准 SQL 接口
      - 实现比较复杂，细节特别多，很容易出现 bug，需要较长的时间才能稳定
      - 数据库中间件自己不执行真正的读写操作，但所有的数据库操作请求都要经过中间件，中间件的性能要求也很高
      - 数据库主从切换对业务服务器无感知，数据库中间件可以探测数据库服务器的主从状态

- 分库分表
  - 分库
    - 业务分库
    - 按照业务模块将数据分散到不同的数据库服务器中
      - 问题
      - join 操作问题
      - 事务问题
      - 成本问题
  - 分表
    - 垂直分表
      - 表操作数量要增加
    - 水平分表
      - 表行数特别大的那种（5000W参考）
      - 复杂性
        - 路由
          - 范围路由
            - 分布不均
            - 表的拓展简单
          - Hash 路由
            - 分布均匀
            - 表的拓展麻烦
          - 配置路由
            - 单独的路由表
            - 简单，灵活
            - 拓展放标
            - 多查一次，影响性能
            - 太大了，死循环
      - join, 多次join问题
      - count问题
        - coun相加
          - 实现简单，性能低
        记录数表
          - 增加写压力
          - 后台更新
  - 实现方法
    - 代码程封装
    - 中间件封装

- 优化顺序
  - 硬件优化
  - 数据库调优
  - 引入缓存
  - 程序与数据库的优化
  - 分库、分表
  
- 数据写双份，一份给线上用，采用分库分表；一份给运营，不分库分表

### Nosql

- 关系数据库存储的是行记录，无法存储数据结构
- 关系数据库的schema拓展很不方便
- 关系数据库在大数据场景下I/O较高
- 关系数据库的全文搜索功能比较弱

解决
- K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表
- 文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表
- 列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表
  - 一般将列式存储应用在离线的大数据分析和统计场景中
- 全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表
  - 全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量会非常多
  - 全文搜索的模糊匹配方式，索引无法满足，只能用 like 查询，而 like 查询是整表扫描，效率非常低
    - 全文搜索引擎的技术原理被称为“倒排索引”（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引

### 缓存架构

- 缓存穿透
  - 缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据
  - 1. 存储数据不存在 -- 双key
  - 2. 缓存数据生成耗费大量时间或者资源
    - 存储系统中存在数据，但生成缓存数据需要耗费较长时间或者耗费大量资源

- 缓存雪崩
  - 缓存雪崩是指当缓存失效（过期）后引起系统性能急剧下降的情况
  - 解决方法
    - 更新锁
      - 对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值
      - 分布锁，如 ZooKeeper
    - 后台更新
      - 由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存
- 缓存热点
  - 缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力

- 双key机制
mysql缓存：
- 1. mysql第一种缓存叫sql语句结果缓存，但条件比较苛刻，程序员不可控，我们的dba线上都关闭这个功能，具体实现可以查一下 
- 2. mysql第二种缓存是innodb buffer pool，缓存的是磁盘上的分页数据，不是sql的查询结果，sql的执行过程省不了。而mc，redis这些实际上都是缓存sql的结果，两种缓存方式，性能差很远。
- 针对常用的分类会统一缓存，缓存会主动更新；不常用的根据查询条件计算md5作为key 进行缓存，缓存时间不长，例如60分钟，防止短时间内大量访问压垮存储，例如爬虫
- 缓存框架，Ehcache


### PPC与TPC

- 高性能架构设
  - 尽量提升单服务器的性能，将单服务器的性能发挥到极致
  - 如果单服务器无法支撑性能，设计服务器集群方案
- 单服务器高性能
  - 服务器采取并发模型
    - 设计点
      - 服务器如何管理连接
      - 服务器如何处理请求
  - PPC（Process Per Connection）
    - 每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX 网络服务器所采用的模型
    - 实现简单，实用于连接数不高
    - 弊端
      - fork 代价高：创建进程代价高，需要分配内核资源，需要将内存映象从父进程复制到子进程
      - 父子进程通信复杂：父进程“fork”子进程后，文件描述符可以通过内存映象复制从父进程传到子进程，但“fork”后，父子进程通信比较麻烦，需要IPC之类的通信方案
      - 支持的并发连接数有限
    - Prefrok
      - 提前创建
  - TPC（Thread Per Connection）
    - 每次有新的连接就新建一个线程去专门处理这个连接的请求
    - 好处
      - 线程更加轻量级，创建线程的消耗比进程小的多
      - 多线程共享内存空间的，线程通信比进程通信更加简单
    - 问题
      - 创建线程代价虽低，高并发下还是有性能问题
      - 无须进程间通信，但是线程间的互斥和共享又引入了新的复杂度，可能导致死锁
      - 多线程会互相影响的情况，某线程异常可能导致整个进程退出
  - TPC还存在CPU线程调度和切换的问题

### Reactor和Proactor

- Reactor
  - I/O 多路复用技术归纳起来有两个关键实现点
    - 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等
    - 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理
  - Reactor 模式三个典型的方案
    - 单 Reactor 单进程/线程
    - 单 Reactor 多线程
    - 多 Reactor 多进程/线程
  - 单 Reactor
    - 只适用于业务处理非常快速的场景 Redis
    - 简单
    - 没有进程通信
    - 没有进程竞争
    - 只有一个进程，无法发挥多核CPU的性能
    - Handler 在处理某个连接上的业务时，整个进程只适用于业务处理非常快速的场景
  - 单 Reactor 多线程
    - 
    - 可以利用多核多CPU的处理能力
    - 多线程共享和访问比较复杂
    - Reactor  承担所有事件的监听和响应，只在主线程中运行，瞬间高并发会成为性能瓶颈
  - 多 Reactor 多进程/线程
    - 实现起来更简单
      - 父子进程的职责非常明确，父进程只负责接受新连接，子进程负责后续的业务处理
      - 父子进程的交互很简单，父进程只需要把新连接传给子进程，子进程无须返回数据
      - 子进程之间是互相独立的，无须同步共享之类的处理
    - 多 Reactor 多进程 Nginx
    - 多 Reactor 多线程 Memcache

- Proactor
  - 异步 I/O
  - Windows 下通过 IOCP 实现了真正的异步 I/O
  - linux下用多线程和epoll来做多reactor

- TPS - T - transaction  写请求
- QPS - Q - query 读请求


### 负载均衡算法

- 任务平分类s
- 负载均衡类
- 性能最优类
- hash类

- 轮询
- 加权轮询
- 负载最低优先
- 性能最优类
- hash 类
  - 源地址hash
  - ID hash


### CAP

- C Consistency
- A Avaliability
- P parttition Tolerance
- P要求分布式和数据同步，C要求数据完全一致，A要求返回及时


### 双机架构

#### 主备复制

- 提供备份服务 
- 优点
  - 实现简单
  - 客户机无需感知备机的存在
  - 主/备机来说，只需进行数据复制即可，无需状态判断及主备切换类的复杂操作
- 缺点
  - 备机只为备份，没有读写操作，硬件成本浪费
  - 故障后需人工干预，无法自动恢复

#### 主从复制

- 提供“读”的服务
- 优点
  - 主机故障，读操作相关业务可以继续运行
  - 从机提供读操作，发挥了硬件性能
- 缺点
  - 客户端感知主从关系，将不同的操作发送给不同的机器进行处理，复杂度比主备复杂度高
  - 从机提供读业务，若主从复制延迟较大，业务数据不一致问题
  - 故障需人工干预
- 写少读多业务， BBD、新闻类网站

#### 双机切换
- 共性问题
  - 主机故障后，无法进行写操作
  - 如果主机无法恢复，需要人工进行新的主机角色
- 主备间状态判断
  - 状态传递的渠道
  - 状态检测的内容
- 切换决策
  - 切换时机
  - 切换策略
  - 自动程度
- 数据冲突解决
- 常见架构
  - 互链式
    - 状态传递的通道本身有故障
    - 多通道、决策复杂
  - 中介式
    - 连接管理更简单
    - 状态决策更简单
    - 中介管理
      - Zookeeper Keepalived
  - 模拟式

#### 主主复制
- 不存在切换
- 无需区分角色
- 数据一致性，双向复制
- 临时性、可丢失、可覆盖的数据场景

### 集群和分区

#### 数据集群

- 数据集中集群
  - 主机如何将数据复制给备机
  - 备机如何检测主机状态
  - 主机故障后，如何决定新的主机（ZooKeeper）
- 数据分散集群
  - 多服务器组成集群，单台负责存储部分数据，备份部分数据
  - 均衡性
  - 容错性
  - 可伸缩性
  
#### 数据分区

  - 考虑：
    - 数据量
    - 分区规则
    - 复制规则
      - 集中式
      - 互备式
      - 独立式

### 设计计算高可用架构

- 任务管理
- 哪些服务器可以执行任务
- 任务如何重新执行
  
#### 主备

- 主机执行所有计算任务。例如，读写数据、执行操作等
- 当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务，此时系统处于不可用状态
- 当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务
- 如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续将任务发送给主机
- 如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机（即原来的备机），同时，为了继续保持主备架构，需要人工增加新的机器作为备机
  - 冷备
  - 温备
  
#### 主从

- 正常情况下，主机执行部分计算任务，备机执行部分计算任务z
- 当主机故障，任务分配器不会自动将原来发送给主机的任务发送给从机，而是继续发送给主机，无论是否成功
- 若主机能够恢复，任务分配器继续按照原有的设计策略分配任务
- 若主机不能恢复，需人工操作，原来从机升级为主机，增加从机
  - 从机也执行任务，发挥从机的硬件性能
  - 任务分类，任务分配器复杂
  
#### 集群

- 对称集群
- 负载均衡集群
  - 选取分配策略
  - 检测服务器状态
- 非对称集群
  - 任务分配策略更加复杂：需要将任务划分为不同类型并分配给不同角色的集群节点
  - 角色分配策略实现比较复杂：ZAB,Raft实现leader

### 异地多活

  本质是通过异地的数据冗余，保证在极端情况下业务也能正常提供给用户
  核心：数据的同步

#### 标准

1. 正常情况下，用户无论访问哪个地方业务系统，都能得到正确的业务服务  
2. 某个业务系统异常，访问其他地方业务系统，能够得到正确的业务系统

#### 架构模式

- 复杂度、成本、发生概率
- 同城异区
  - 机房级别的故障最优
  - 延迟较小，当做本地机房
- 跨城异地
  - 距离较远带来网络延迟问题
  - 数据强一致性不适用
- 跨国异地
  - 为不同地区的用户提供服务
  - 只读类业务做多活

#### 技巧

  使用多种手段，保证绝大部分用户的核心业务异地多活

- 保证核心业务的异地多活
- 保证核心业务的最终一致性
  - 尽量减少异地多活机房的距离，搭建高速网络
  - 尽量减少数据同步，只同步核心业务相关的数据
  - 保证最终一致性，不保证实时一致性
- 采用多种手段同步数据
  - mysql5.1 单线程的复制
  - 避免只使用存储系统自带的同步功能
  - 消息队列方式
  - 二次读取
  - 存储系统同步方式
  - 回源读方式
  - 重新生成数据方式
- 只保证绝大部分用户的异地多活

#### 步骤

- 业务分级
  - 只为核心业务设计异地多活，降低整体复杂度和实现成本
  - 分级标准
    - 访问量达的业务
    - 核心业务
    - 收入业务
- 数据分类
  - 数据特征分析维度
    - 数据量
    - 唯一性
    - 实时性
    - 可丢失性
    - 可恢复性
- 数据同步
  - 存储系统同步
  - 消息队列同步
    - 无事物或无时序性
  - 重复生成
- 异常处理
  - 目的
    - 问题发生时，避免少量数据异常导致整体业务不可用
    - 问题恢复后，将异常的数据进行修正
    - 对用户进行安抚，弥补用户损失
  - 处理措施
    - 多通道同步
    - 同步和访问结合
    - 日志记录
    - 用户补偿

### 接口级故障

  解决的核心思想：优先保证核心业务和优先保证绝大部分用户

#### 原因

- 内部原因
- 外部元音

#### 降级

  应对系统自身的故障

- 系统后门降级
  - 系统预留了后门用于降级操作

- 独立降级系统
  
#### 熔断
  
  应对依赖的外部系统故障

#### 限流
  
  只允许系统能够承受的访问量进来，超出系统访问的请求将被丢弃

- 基于请求限流
  - 限制总量
  - 限制时间量
- 基于资源限流
  
#### 排队

- 消息队列排队
  
### 可扩展架构
  
  拆

#### 拆分思路

- 面向流程拆分
- 面向服务拆分
- 面向功能拆分
- 不同的拆分方式，本质上决定了系统的扩展方式
  - 面向流程拆分
    - 扩展时大部分情况只需要修改某一层，少部分情况可能修改关联的两层，不会出现所有层都同时要修改
    - 分成架构
  - 面向服务拆分
    - 对某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可，无须修改所有的服务
    - SOA, 微服务
  - 面向功能拆分
    - 对某个功能扩展，或者要增加新的功能时，只需要扩展相关功能即可，无须修改所有的服务 
    - 微内核架构
  
#### 分层架构

##### C/S 架构、B/S 架构

  划分对象是整个业务系统，划分维度是用户交互，即将用户交互部分独立成一层，支撑用户交互的后台作为另外一层

##### MVC架构、MVP架构
  
  划分对象时单个业务子系统，划分维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活

##### 逻辑分层架构
  
  核心之一：需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构
  划分对象可以是单个业务子系统，也可以是整个业务系统，划分维度是职责

  隔离关注点
  分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展
  另一特点：层层传递

##### SOA (Service Oriented Architecture） 面向服务架构

解决重复建设和扩展效率低

- 服务
- ESB (Enterprise Service Bus) 企业服务总线
- 松耦合

### 微服务

#### 服务粒度

  SOA 服务粒度粗点，微服务 粒度要低点

#### 服务通信
  
  SOA 采用ESB作为服务间的关键组件，负责服务定义、服务路由、消息转换、消息传递，总体上是重量级的实现

  微服务推荐使用统一的协议和格式

#### 服务交付

  SOA 对服务交付并没有特殊要求
  要求快速交付，相应地要求采取自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践

#### 应用场景

  SOA 更加适合庞大、复杂、异构的企业级系统
  快速、轻量级、基于web的互联网系统，这类系统业务变换快，需要快速尝试、快速交付

| 对比维度 | SOA | 微服务|
| :---: | :----: | :----: |
| 服务粒度 | 粗         | 细 |
| 服务通信 | 重量级，ESB | 轻量级，HTTP或REST |
| 服务交付 | 慢         | 快 |
| 应用场景 | 企业级     | 互联网 |

#### 坑

- 服务划分过细，服务间关系复杂
- 服务数量太多，团队效率急剧下降
- 调用链太长，性能下降
- 调用链太长，问题定位困难
- 没有自动化支撑，无法快速交付
- 没有服务治理，微服务数量多了后管理混乱

#### 方法

  陷阱

- 微服务拆分过细，过分强调“small”。 
- 微服务基础设施不健全，忽略了“automated”。
- 微服务并不轻量级，规模大了后，“lightweight”不再适应。

##### 服务粒度
  
  三个火枪手

##### 拆分方法

- 基于业务逻辑拆分
- 基于可扩展拆分
  - 稳定服务
  - 变动服务
- 基于可靠性拆分
  - 好处
    - 避免非核心服务故障影响核心服务
    - 核心服务高可用方案可以更简单
    - 能够降低高可用成本
    - 基于性能拆分
- 基于性能拆分

##### 优先级

- 服务发现、服务路由、服务容错：基本的微服务基础设施
- 接口框架、API网关：主要是提升开发效率，接口框架是提升内内部系统的开发效率，API网关是为了提升与外部服务对接效率
- 自动化部署、自动化测试、配置中心：主要是进一步提升运维效率
- 服务监控、服务跟踪、服务安全：主要是进一步提升运维效率

#### 基础设施

##### 自动化测试

- 代码级 单元测试
- 系统级 集成测试
- 系统间 接口测试

##### 自动化部署

- 版本管理
- 资源管理
- 部署操作
- 回退操作

##### 配置中心

- 配置版本管理
- 增删改查配置
- 节点管理
- 配置同步
- 配置推送

##### 接口框架

- HTTP
- REST

##### API网关

  系统拆分微服务后，内部的微服务之间是互联互通的，相互间的访问点对点

##### 服务发现

- 自理式
  每个微服务完成服务发现
- 代理式
  负载均衡系统完成微服务间的服务发现

##### 服务路由

##### 服务容错

##### 服务监控

  节点数增加导致需要监控的机器、网络、进程、接口调用数等监控对象的数量大大增加，
  同时，一旦发生故障，我们需要快速根据各类信息来定位故障

  主要作用
  - 实时搜集信息并进行分析，避免故障后再来分析，减少了处理时间
  - 服务监控可以在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警，降低了问题影响的范围和时间

##### 服务跟踪

  服务监控和服务跟踪的区别可以简单概括为宏观和微观的区别

##### 服务安全

- 接入安全
- 数据安全
- 传输安全
  
### 微内核架构（插件化架构）
  
  面向功能进行拆分的可扩展性架构
  基于产品的应用

#### 基本架构

##### 核心系统

  核心系统负责和具体业务功能无关的通用功能
  
##### 插件模块

  插件模块负责实现具体的业务逻辑

##### 设计关键技术

- 插件管理
  插件注册表机制
- 插件连接
  如何连接到核心系统
- 插件通信
  插件间的通信

##### OSGI 架构简析

  Open Services Gateway initiative
  OSGI 具备动态化、热插拔、高可复用性、高效性、扩展方便等优点

##### 规则引擎架构解析

- 可拓展
  业务逻辑实现与业务系统分离，可以在不改动业务系统的情况下扩展新的业务功能
- 易理解
  规则通过自然语言描述，业务人员易于理解和操作，而不像代码那样只有程序员才能理解和开发
- 高效率
  规则引擎系统一般提供可视化的规则定制、审批、查询及管理，方便业务人员快速配置新的业务

实现

- 插件管理
- 插件连接
- 插件通信